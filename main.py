# -*- coding: utf-8 -*-
"""Backend GeloFácil com Python e FastAPI

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m5V5EQpA6OS3ZpMlfzEZ0PuWx-IFyzQe
"""

# GeloFácil - Backend com FastAPI
#
# INSTRUÇÕES DE INSTALAÇÃO:
# 1. Salve este arquivo como `main.py`.
# 2. Crie um arquivo chamado `requirements.txt` na mesma pasta e adicione o conteúdo abaixo:
#
# fastapi
# uvicorn[standard]
# sqlalchemy
# pydantic
# python-jose[cryptography]
# passlib[bcrypt]
# python-multipart
#
# 3. Instale as dependências com o comando: pip install -r requirements.txt
# 4. Rode o servidor com o comando: uvicorn main:app --reload

# ===============================================================================
# 1. IMPORTAÇÕES E CONFIGURAÇÃO INICIAL
# ===============================================================================
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy import create_engine, Column, Integer, String, Float, Boolean, DateTime, ForeignKey, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import List, Optional
import os

# Módulos de segurança
from jose import JWTError, jwt
from passlib.context import CryptContext

# ===============================================================================
# 2. CONFIGURAÇÃO DO BANCO DE DADOS (SQLALCHEMY)
# ===============================================================================
# Usaremos SQLite para simplicidade. O nome do arquivo do banco será "gelofacil.db"
DATABASE_URL = "sqlite:///./gelofacil.db"

# Engine de conexão com o banco
engine = create_engine(
    DATABASE_URL, connect_args={"check_same_thread": False}
)

# Sessão para interagir com o banco
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base para os modelos ORM (tabelas)
Base = declarative_base()

# Função para obter uma sessão do banco de dados em cada requisição
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ===============================================================================
# 3. MODELOS DO BANCO DE DADOS (TABELAS)
# ===============================================================================

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)

class Product(Base):
    __tablename__ = "products"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    quantity = Column(Integer, nullable=False)
    min_stock = Column(Integer, default=10)
    price = Column(Float, nullable=False)

class Customer(Base):
    __tablename__ = "customers"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    contact = Column(String, nullable=True)
    email = Column(String, nullable=True)
    phone = Column(String, nullable=True)
    address = Column(String, nullable=True)

class Sale(Base):
    __tablename__ = "sales"
    id = Column(Integer, primary_key=True, index=True)
    customer_id = Column(Integer, ForeignKey("customers.id"))
    total = Column(Float, nullable=False)
    payment_method = Column(String, nullable=False)
    paid = Column(Boolean, default=False)
    date = Column(DateTime, default=datetime.utcnow)
    notes = Column(String, nullable=True)

    customer = relationship("Customer")
    items = relationship("SaleItem", back_populates="sale", cascade="all, delete-orphan")

class SaleItem(Base):
    __tablename__ = "sale_items"
    id = Column(Integer, primary_key=True, index=True)
    sale_id = Column(Integer, ForeignKey("sales.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Integer, nullable=False)
    unit_price = Column(Float, nullable=False)
    total_price = Column(Float, nullable=False)

    sale = relationship("Sale", back_populates="items")
    product = relationship("Product")

class Expense(Base):
    __tablename__ = "expenses"
    id = Column(Integer, primary_key=True, index=True)
    description = Column(String, nullable=False)
    supplier = Column(String, nullable=False)  # Fornecedor
    category = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    due_date = Column(DateTime, nullable=False)
    paid = Column(Boolean, default=False)
    paid_date = Column(DateTime, nullable=True)
    notes = Column(String, nullable=True)
    # Relacionamento com produto (opcional - para despesas que impactam custo específico)
    product_id = Column(Integer, ForeignKey("products.id"), nullable=True)
    product = relationship("Product")

# ===============================================================================
# 4. SCHEMAS (PYDANTIC - VALIDAÇÃO DE DADOS DA API)
# ===============================================================================
# Schemas definem como os dados devem ser na entrada e saída da API

class UserCreate(BaseModel):
    email: str
    password: str

class UserOut(BaseModel):
    id: int
    email: str
    is_active: bool
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

# Schemas para Produtos
class ProductCreate(BaseModel):
    name: str
    quantity: int
    min_stock: int = 10
    price: float

class ProductUpdate(BaseModel):
    name: Optional[str] = None
    quantity: Optional[int] = None
    min_stock: Optional[int] = None
    price: Optional[float] = None

class ProductOut(BaseModel):
    id: int
    name: str
    quantity: int
    min_stock: int
    price: float
    class Config:
        from_attributes = True

# Schemas para Clientes
class CustomerCreate(BaseModel):
    name: str
    contact: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

class CustomerUpdate(BaseModel):
    name: Optional[str] = None
    contact: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

class CustomerOut(BaseModel):
    id: int
    name: str
    contact: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    class Config:
        from_attributes = True

# Schemas para Vendas
class SaleItemCreate(BaseModel):
    product_id: int
    quantity: int
    unit_price: float

class SaleItemOut(BaseModel):
    id: int
    product_id: int
    quantity: int
    unit_price: float
    total_price: float
    product_name: str
    class Config:
        from_attributes = True

class SaleCreate(BaseModel):
    customer_id: int
    payment_method: str
    paid: bool = False
    notes: Optional[str] = None
    items: List[SaleItemCreate]

class SaleUpdate(BaseModel):
    customer_id: Optional[int] = None
    payment_method: Optional[str] = None
    paid: Optional[bool] = None
    notes: Optional[str] = None

class SaleOut(BaseModel):
    id: int
    customer_id: int
    customer_name: str
    total: float
    payment_method: str
    paid: bool
    date: datetime
    notes: Optional[str] = None
    items: List[SaleItemOut]
    class Config:
        from_attributes = True

# Schemas para Despesas (Contas a Pagar)
class ExpenseCreate(BaseModel):
    description: str
    supplier: str
    category: str
    amount: float
    due_date: datetime
    notes: Optional[str] = None
    product_id: Optional[int] = None  # Produto que será impactado pelo custo

class ExpenseUpdate(BaseModel):
    description: Optional[str] = None
    supplier: Optional[str] = None
    category: Optional[str] = None
    amount: Optional[float] = None
    due_date: Optional[datetime] = None
    paid: Optional[bool] = None
    notes: Optional[str] = None
    product_id: Optional[int] = None

class ExpenseOut(BaseModel):
    id: int
    description: str
    supplier: str
    category: str
    amount: float
    due_date: datetime
    paid: bool
    paid_date: Optional[datetime] = None
    notes: Optional[str] = None
    product_id: Optional[int] = None
    product_name: Optional[str] = None
    days_until_due: Optional[int] = None
    class Config:
        from_attributes = True

# ===============================================================================
# 5. CONFIGURAÇÃO DE SEGURANÇA E AUTENTICAÇÃO
# ===============================================================================
# Chave secreta para criar os tokens JWT. Em produção, use uma chave mais complexa!
SECRET_KEY = "uma-chave-secreta-muito-forte-para-o-gelofacil"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 # Token expira em 60 minutos

# Contexto para criptografia de senhas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Esquema de autenticação OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_password(plain_password, hashed_password):
    """Verifica se a senha plana corresponde à senha criptografada."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    """Gera o hash de uma senha."""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """Cria um novo token de acesso."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    """Decodifica o token e retorna o usuário atual."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Não foi possível validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = TokenData(email=email)
    except JWTError:
        raise credentials_exception

    user = db.query(User).filter(User.email == token_data.email).first()
    if user is None:
        raise credentials_exception
    return user

# ===============================================================================
# 6. INICIALIZAÇÃO DA APLICAÇÃO FASTAPI
# ===============================================================================
app = FastAPI(
    title="GeloFácil API",
    description="API para o sistema de gestão de fábrica de gelo.",
    version="1.0.0"
)

# Configurar arquivos estáticos
app.mount("/static", StaticFiles(directory="."), name="static")

# Cria as tabelas no banco de dados na primeira vez que o app é iniciado
Base.metadata.create_all(bind=engine)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Permite qualquer origem
    allow_credentials=True,
    allow_methods=["*"],  # Permite todos os métodos HTTP
    allow_headers=["*"],  # Permite todos os cabeçalhos
)

# ===============================================================================
# 7. ENDPOINTS (ROTAS DA API)
# ===============================================================================

@app.get("/", tags=["Frontend"])
async def read_root():
    """Serve o frontend HTML."""
    return FileResponse("index.html")

@app.get("/api", tags=["Root"])
def read_api_root():
    """Endpoint raiz da API."""
    return {"message": "Bem-vindo à API do GeloFácil!"}

@app.post("/token", response_model=Token, tags=["Autenticação"])
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    """
    Endpoint de login. Recebe email (no campo username) e senha.
    Retorna um token de acesso se as credenciais forem válidas.
    """
    user = db.query(User).filter(User.email == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Email ou senha incorretos",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/users/register", response_model=UserOut, status_code=status.HTTP_201_CREATED, tags=["Autenticação"])
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """
    Endpoint para registrar um novo usuário no sistema.
    """
    db_user = db.query(User).filter(User.email == user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Este email já está registrado")

    hashed_password = get_password_hash(user.password)
    db_user = User(email=user.email, hashed_password=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


@app.get("/users/me", response_model=UserOut, tags=["Usuários"])
async def read_users_me(current_user: User = Depends(get_current_user)):
    """
    Endpoint para verificar o usuário atualmente logado.
    Requer um token de acesso válido.
    """
    return current_user

# ===============================================================================
# 8. ENDPOINTS PARA PRODUTOS
# ===============================================================================

@app.get("/products/", response_model=List[ProductOut], tags=["Produtos"])
async def get_products(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Lista todos os produtos."""
    products = db.query(Product).all()
    return products

@app.get("/products/{product_id}", response_model=ProductOut, tags=["Produtos"])
async def get_product(product_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Obtém um produto específico por ID."""
    product = db.query(Product).filter(Product.id == product_id).first()
    if not product:
        raise HTTPException(status_code=404, detail="Produto não encontrado")
    return product

@app.post("/products/", response_model=ProductOut, status_code=status.HTTP_201_CREATED, tags=["Produtos"])
async def create_product(product: ProductCreate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Cria um novo produto."""
    db_product = Product(
        name=product.name,
        quantity=product.quantity,
        min_stock=product.min_stock,
        price=product.price
    )
    db.add(db_product)
    db.commit()
    db.refresh(db_product)
    return db_product

@app.put("/products/{product_id}", response_model=ProductOut, tags=["Produtos"])
async def update_product(product_id: int, product_update: ProductUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Atualiza um produto existente."""
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Produto não encontrado")
    
    update_data = product_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_product, field, value)
    
    db.commit()
    db.refresh(db_product)
    return db_product

@app.delete("/products/{product_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Produtos"])
async def delete_product(product_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Deleta um produto."""
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Produto não encontrado")
    
    db.delete(db_product)
    db.commit()
    return None

# ===============================================================================
# 9. ENDPOINTS PARA CLIENTES
# ===============================================================================

@app.get("/customers/", response_model=List[CustomerOut], tags=["Clientes"])
async def get_customers(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Lista todos os clientes."""
    customers = db.query(Customer).all()
    return customers

@app.get("/customers/{customer_id}", response_model=CustomerOut, tags=["Clientes"])
async def get_customer(customer_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Obtém um cliente específico por ID."""
    customer = db.query(Customer).filter(Customer.id == customer_id).first()
    if not customer:
        raise HTTPException(status_code=404, detail="Cliente não encontrado")
    return customer

@app.post("/customers/", response_model=CustomerOut, status_code=status.HTTP_201_CREATED, tags=["Clientes"])
async def create_customer(customer: CustomerCreate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Cria um novo cliente."""
    db_customer = Customer(
        name=customer.name,
        contact=customer.contact,
        email=customer.email,
        phone=customer.phone,
        address=customer.address
    )
    db.add(db_customer)
    db.commit()
    db.refresh(db_customer)
    return db_customer

@app.put("/customers/{customer_id}", response_model=CustomerOut, tags=["Clientes"])
async def update_customer(customer_id: int, customer_update: CustomerUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Atualiza um cliente existente."""
    db_customer = db.query(Customer).filter(Customer.id == customer_id).first()
    if not db_customer:
        raise HTTPException(status_code=404, detail="Cliente não encontrado")
    
    update_data = customer_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_customer, field, value)
    
    db.commit()
    db.refresh(db_customer)
    return db_customer

@app.delete("/customers/{customer_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Clientes"])
async def delete_customer(customer_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Deleta um cliente."""
    db_customer = db.query(Customer).filter(Customer.id == customer_id).first()
    if not db_customer:
        raise HTTPException(status_code=404, detail="Cliente não encontrado")
    
    db.delete(db_customer)
    db.commit()
    return None

# ===============================================================================
# 10. ENDPOINTS PARA VENDAS
# ===============================================================================

@app.get("/sales/", response_model=List[SaleOut], tags=["Vendas"])
async def get_sales(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Lista todas as vendas."""
    sales = db.query(Sale).all()
    result = []
    for sale in sales:
        sale_data = {
            "id": sale.id,
            "customer_id": sale.customer_id,
            "customer_name": sale.customer.name,
            "total": sale.total,
            "payment_method": sale.payment_method,
            "paid": sale.paid,
            "date": sale.date,
            "notes": sale.notes,
            "items": []
        }
        for item in sale.items:
            item_data = {
                "id": item.id,
                "product_id": item.product_id,
                "quantity": item.quantity,
                "unit_price": item.unit_price,
                "total_price": item.total_price,
                "product_name": item.product.name
            }
            sale_data["items"].append(item_data)
        result.append(sale_data)
    return result

@app.get("/sales/{sale_id}", response_model=SaleOut, tags=["Vendas"])
async def get_sale(sale_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Obtém uma venda específica por ID."""
    sale = db.query(Sale).filter(Sale.id == sale_id).first()
    if not sale:
        raise HTTPException(status_code=404, detail="Venda não encontrada")
    
    sale_data = {
        "id": sale.id,
        "customer_id": sale.customer_id,
        "customer_name": sale.customer.name,
        "total": sale.total,
        "payment_method": sale.payment_method,
        "paid": sale.paid,
        "date": sale.date,
        "notes": sale.notes,
        "items": []
    }
    for item in sale.items:
        item_data = {
            "id": item.id,
            "product_id": item.product_id,
            "quantity": item.quantity,
            "unit_price": item.unit_price,
            "total_price": item.total_price,
            "product_name": item.product.name
        }
        sale_data["items"].append(item_data)
    return sale_data

@app.post("/sales/", response_model=SaleOut, status_code=status.HTTP_201_CREATED, tags=["Vendas"])
async def create_sale(sale: SaleCreate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Cria uma nova venda."""
    # Verificar se o cliente existe
    customer = db.query(Customer).filter(Customer.id == sale.customer_id).first()
    if not customer:
        raise HTTPException(status_code=404, detail="Cliente não encontrado")
    
    # Calcular total da venda
    total = 0
    for item in sale.items:
        # Verificar se o produto existe e tem estoque suficiente
        product = db.query(Product).filter(Product.id == item.product_id).first()
        if not product:
            raise HTTPException(status_code=404, detail=f"Produto ID {item.product_id} não encontrado")
        if product.quantity < item.quantity:
            raise HTTPException(status_code=400, detail=f"Estoque insuficiente para {product.name}")
        
        item_total = item.quantity * item.unit_price
        total += item_total
    
    # Criar a venda
    db_sale = Sale(
        customer_id=sale.customer_id,
        total=total,
        payment_method=sale.payment_method,
        paid=sale.paid,
        notes=sale.notes
    )
    db.add(db_sale)
    db.flush()  # Para obter o ID da venda
    
    # Criar os itens da venda e atualizar estoque
    for item in sale.items:
        product = db.query(Product).filter(Product.id == item.product_id).first()
        
        # Criar item da venda
        sale_item = SaleItem(
            sale_id=db_sale.id,
            product_id=item.product_id,
            quantity=item.quantity,
            unit_price=item.unit_price,
            total_price=item.quantity * item.unit_price
        )
        db.add(sale_item)
        
        # Atualizar estoque do produto
        product.quantity -= item.quantity
    
    db.commit()
    db.refresh(db_sale)
    
    # Retornar a venda criada
    return await get_sale(db_sale.id, db, current_user)

@app.put("/sales/{sale_id}", response_model=SaleOut, tags=["Vendas"])
async def update_sale(sale_id: int, sale_update: SaleUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Atualiza uma venda existente."""
    db_sale = db.query(Sale).filter(Sale.id == sale_id).first()
    if not db_sale:
        raise HTTPException(status_code=404, detail="Venda não encontrada")
    
    update_data = sale_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_sale, field, value)
    
    db.commit()
    db.refresh(db_sale)
    return await get_sale(sale_id, db, current_user)

@app.delete("/sales/{sale_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Vendas"])
async def delete_sale(sale_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Deleta uma venda."""
    db_sale = db.query(Sale).filter(Sale.id == sale_id).first()
    if not db_sale:
        raise HTTPException(status_code=404, detail="Venda não encontrada")
    
    # Restaurar estoque dos produtos
    for item in db_sale.items:
        product = db.query(Product).filter(Product.id == item.product_id).first()
        if product:
            product.quantity += item.quantity
    
    db.delete(db_sale)
    db.commit()
    return None

# ===============================================================================
# ENDPOINTS PARA DESPESAS (CONTAS A PAGAR)
# ===============================================================================

@app.get("/expenses/", response_model=List[ExpenseOut], tags=["Despesas"])
async def get_expenses(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Lista todas as despesas."""
    expenses = db.query(Expense).all()
    expense_list = []
    
    for expense in expenses:
        expense_data = {
            "id": expense.id,
            "description": expense.description,
            "supplier": expense.supplier,
            "category": expense.category,
            "amount": expense.amount,
            "due_date": expense.due_date,
            "paid": expense.paid,
            "paid_date": expense.paid_date,
            "notes": expense.notes,
            "product_id": expense.product_id,
            "product_name": expense.product.name if expense.product else None,
            "days_until_due": (expense.due_date - datetime.utcnow()).days if not expense.paid else None
        }
        expense_list.append(expense_data)
    
    return expense_list

@app.get("/expenses/{expense_id}", response_model=ExpenseOut, tags=["Despesas"])
async def get_expense(expense_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Obtém uma despesa específica por ID."""
    expense = db.query(Expense).filter(Expense.id == expense_id).first()
    if not expense:
        raise HTTPException(status_code=404, detail="Despesa não encontrada")
    
    expense_data = {
        "id": expense.id,
        "description": expense.description,
        "supplier": expense.supplier,
        "category": expense.category,
        "amount": expense.amount,
        "due_date": expense.due_date,
        "paid": expense.paid,
        "paid_date": expense.paid_date,
        "notes": expense.notes,
        "product_id": expense.product_id,
        "product_name": expense.product.name if expense.product else None,
        "days_until_due": (expense.due_date - datetime.utcnow()).days if not expense.paid else None
    }
    return expense_data

@app.post("/expenses/", response_model=ExpenseOut, status_code=status.HTTP_201_CREATED, tags=["Despesas"])
async def create_expense(expense: ExpenseCreate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Cria uma nova despesa."""
    # Verificar se o produto existe (se fornecido)
    if expense.product_id:
        product = db.query(Product).filter(Product.id == expense.product_id).first()
        if not product:
            raise HTTPException(status_code=404, detail="Produto não encontrado")
    
    db_expense = Expense(
        description=expense.description,
        supplier=expense.supplier,
        category=expense.category,
        amount=expense.amount,
        due_date=expense.due_date,
        notes=expense.notes,
        product_id=expense.product_id
    )
    
    db.add(db_expense)
    db.commit()
    db.refresh(db_expense)
    
    # Retornar a despesa criada
    return await get_expense(db_expense.id, db, current_user)

@app.put("/expenses/{expense_id}", response_model=ExpenseOut, tags=["Despesas"])
async def update_expense(expense_id: int, expense_update: ExpenseUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Atualiza uma despesa existente."""
    db_expense = db.query(Expense).filter(Expense.id == expense_id).first()
    if not db_expense:
        raise HTTPException(status_code=404, detail="Despesa não encontrada")
    
    # Se está marcando como paga, definir a data de pagamento
    if expense_update.paid and not db_expense.paid:
        db_expense.paid_date = datetime.utcnow()
    
    update_data = expense_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_expense, field, value)
    
    db.commit()
    db.refresh(db_expense)
    return await get_expense(expense_id, db, current_user)

@app.delete("/expenses/{expense_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Despesas"])
async def delete_expense(expense_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Deleta uma despesa."""
    db_expense = db.query(Expense).filter(Expense.id == expense_id).first()
    if not db_expense:
        raise HTTPException(status_code=404, detail="Despesa não encontrada")
    
    db.delete(db_expense)
    db.commit()
    return None

# ===============================================================================
# ENDPOINTS PARA CÁLCULO DE CUSTOS
# ===============================================================================

@app.get("/products/{product_id}/cost", tags=["Produtos"])
async def get_product_cost(product_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Calcula o custo total de um produto incluindo despesas relacionadas."""
    product = db.query(Product).filter(Product.id == product_id).first()
    if not product:
        raise HTTPException(status_code=404, detail="Produto não encontrado")
    
    # Buscar despesas relacionadas ao produto
    expenses = db.query(Expense).filter(Expense.product_id == product_id).all()
    
    # Calcular custo total das despesas
    total_expenses = sum(expense.amount for expense in expenses)
    
    # Calcular custo por unidade (assumindo que as despesas são distribuídas pelo estoque atual)
    cost_per_unit = total_expenses / product.quantity if product.quantity > 0 else 0
    
    return {
        "product_id": product.id,
        "product_name": product.name,
        "current_quantity": product.quantity,
        "total_expenses": total_expenses,
        "cost_per_unit": cost_per_unit,
        "current_price": product.price,
        "profit_margin": product.price - cost_per_unit if cost_per_unit > 0 else product.price,
        "expenses_count": len(expenses)
    }

# ===============================================================================
# ENDPOINTS PARA DASHBOARD
# ===============================================================================

@app.get("/dashboard/payment-methods", tags=["Dashboard"])
async def get_payment_methods_stats(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Retorna estatísticas de formas de pagamento em porcentagem."""
    sales = db.query(Sale).all()
    
    if not sales:
        return {
            "labels": [],
            "data": [],
            "total_sales": 0
        }
    
    # Contar formas de pagamento
    payment_counts = {}
    total_sales = len(sales)
    
    for sale in sales:
        method = sale.payment_method
        payment_counts[method] = payment_counts.get(method, 0) + 1
    
    # Calcular porcentagens
    labels = list(payment_counts.keys())
    data = [(payment_counts[label] / total_sales) * 100 for label in labels]
    
    return {
        "labels": labels,
        "data": data,
        "total_sales": total_sales
    }

@app.get("/dashboard/financial-overview", tags=["Dashboard"])
async def get_financial_overview(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Retorna visão geral financeira: faturamento, lucro e custo."""
    # Calcular faturamento total
    sales = db.query(Sale).filter(Sale.paid == True).all()
    total_revenue = sum(sale.total for sale in sales)
    
    # Calcular custos totais (despesas pagas)
    expenses = db.query(Expense).filter(Expense.paid == True).all()
    total_costs = sum(expense.amount for expense in expenses)
    
    # Calcular lucro
    total_profit = total_revenue - total_costs
    
    # Calcular custo dos produtos vendidos
    sold_products = db.query(SaleItem).join(Sale).filter(Sale.paid == True).all()
    product_costs = 0
    
    for item in sold_products:
        # Buscar despesas relacionadas ao produto
        product_expenses = db.query(Expense).filter(
            Expense.product_id == item.product_id,
            Expense.paid == True
        ).all()
        
        if product_expenses:
            # Calcular custo por unidade do produto
            total_product_expenses = sum(exp.amount for exp in product_expenses)
            product = db.query(Product).filter(Product.id == item.product_id).first()
            if product and product.quantity > 0:
                cost_per_unit = total_product_expenses / product.quantity
                product_costs += cost_per_unit * item.quantity
    
    # Lucro líquido (faturamento - custos de produtos - despesas gerais)
    net_profit = total_revenue - product_costs - total_costs
    
    return {
        "total_revenue": total_revenue,
        "total_costs": total_costs,
        "product_costs": product_costs,
        "gross_profit": total_profit,
        "net_profit": net_profit,
        "total_sales": len(sales),
        "total_expenses": len(expenses)
    }

@app.get("/dashboard/top-customers", tags=["Dashboard"])
async def get_top_customers(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Retorna ranking dos melhores clientes por valor de compras."""
    # Buscar vendas pagas agrupadas por cliente
    customer_sales = db.query(
        Customer.id,
        Customer.name,
        func.sum(Sale.total).label('total_spent'),
        func.count(Sale.id).label('purchase_count')
    ).join(Sale).filter(Sale.paid == True).group_by(Customer.id).order_by(
        func.sum(Sale.total).desc()
    ).limit(10).all()
    
    customers_data = []
    for customer in customer_sales:
        customers_data.append({
            "id": customer.id,
            "name": customer.name,
            "total_spent": float(customer.total_spent),
            "purchase_count": customer.purchase_count,
            "average_ticket": float(customer.total_spent) / customer.purchase_count if customer.purchase_count > 0 else 0
        })
    
    return customers_data

@app.get("/dashboard/sales-trend", tags=["Dashboard"])
async def get_sales_trend(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Retorna tendência de vendas dos últimos 7 dias."""
    from datetime import timedelta
    
    # Data de 7 dias atrás
    seven_days_ago = datetime.utcnow() - timedelta(days=7)
    
    # Buscar vendas dos últimos 7 dias
    recent_sales = db.query(Sale).filter(
        Sale.date >= seven_days_ago,
        Sale.paid == True
    ).all()
    
    # Agrupar por dia
    daily_sales = {}
    for sale in recent_sales:
        date_key = sale.date.strftime('%Y-%m-%d')
        if date_key not in daily_sales:
            daily_sales[date_key] = 0
        daily_sales[date_key] += sale.total
    
    # Preencher dias sem vendas com 0
    dates = []
    values = []
    for i in range(7):
        date = (datetime.utcnow() - timedelta(days=6-i)).strftime('%Y-%m-%d')
        dates.append(date)
        values.append(daily_sales.get(date, 0))
    
    return {
        "labels": dates,
        "data": values
    }

@app.get("/dashboard/stock-alerts", tags=["Dashboard"])
async def get_stock_alerts(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    """Retorna produtos com estoque baixo."""
    low_stock_products = db.query(Product).filter(
        Product.quantity <= Product.min_stock
    ).all()
    
    alerts = []
    for product in low_stock_products:
        alerts.append({
            "id": product.id,
            "name": product.name,
            "current_quantity": product.quantity,
            "min_stock": product.min_stock,
            "status": "CRÍTICO" if product.quantity == 0 else "BAIXO"
        })
    
    return alerts

# Aqui adicionaremos os outros endpoints (CRUD para produtos, vendas, etc.)